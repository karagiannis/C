cd src && make test
make[1]: Entering directory '/home/lasse/Documents/C-programs/C/redis-5.0.7/src'
Cleanup: may take some time... OK
Starting test server at port 11111
[ready]: 74725
[1;37;49mTesting unit/printver[0m
[ready]: 74726
[1;37;49mTesting unit/dump[0m
[ready]: 74727
[1;37;49mTesting unit/auth[0m
[ready]: 74728
[1;37;49mTesting unit/protocol[0m
[ready]: 74729
[1;37;49mTesting unit/keyspace[0m
[ready]: 74730
[1;37;49mTesting unit/scan[0m
[ready]: 74731
[1;37;49mTesting unit/type/string[0m
[ready]: 74732
[1;37;49mTesting unit/type/incr[0m
[ready]: 74733
[1;37;49mTesting unit/type/list[0m
[ready]: 74734
[1;37;49mTesting unit/type/list-2[0m
[ready]: 74735
[1;37;49mTesting unit/type/list-3[0m
[ready]: 74736
[1;37;49mTesting unit/type/set[0m
[ready]: 74738
[1;37;49mTesting unit/type/zset[0m
[ready]: 74737
[1;37;49mTesting unit/type/hash[0m
[ready]: 74739
[1;37;49mTesting unit/type/stream[0m
[ready]: 74740
[1;37;49mTesting unit/type/stream-cgroups[0m
Testing Redis version 5.0.7 (c0b36277)
[[0;32;49mok[0m]: Handle an empty query
[[0;32;49mok[0m]: AUTH fails if there is no password configured server side
[[0;32;49mok[0m]: SET and GET an item
[[0;32;49mok[0m]: SET and GET an empty item
[[0;32;49mok[0m]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - ziplist
[[0;32;49mok[0m]: Negative multibulk length
[[0;32;49mok[0m]: Out of range multibulk length
[[0;32;49mok[0m]: Wrong multibulk payload header
[[0;32;49mok[0m]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - regular list
[[0;32;49mok[0m]: Negative multibulk payload length
[[0;32;49mok[0m]: R/LPOP against empty list
[[0;32;49mok[0m]: Out of range multibulk payload length
[[0;32;49mok[0m]: Non-number multibulk payload length
[[0;32;49mok[0m]: Variadic RPUSH/LPUSH
[[0;32;49mok[0m]: Multi bulk request not followed by bulk arguments
[[0;32;49mok[0m]: Generic wrong number of args
[[0;32;49mok[0m]: DEL a list
[[0;32;49mok[0m]: INCR against non existing key
[[0;32;49mok[0m]: INCR against key created by incr itself
[[0;32;49mok[0m]: Unbalanced number of quotes
[[0;32;49mok[0m]: HSET/HLEN - Small hash creation
[[0;32;49mok[0m]: INCR against key originally set with SET
[[0;32;49mok[0m]: INCR over 32bit value
[[0;32;49mok[0m]: DUMP / RESTORE are able to serialize / unserialize a simple key
[[0;32;49mok[0m]: Is the small hash encoded with a ziplist?
[[0;32;49mok[0m]: INCRBY over 32bit value with over 32bit increment
[[0;32;49mok[0m]: INCR fails against key with spaces (left)
[[0;32;49mok[0m]: RESTORE can set an arbitrary expire to the materialized key
[[0;32;49mok[0m]: INCR fails against key with spaces (right)
[[0;32;49mok[0m]: RESTORE can set an expire that overflows a 32 bit integer
[[0;32;49mok[0m]: INCR fails against key with spaces (both)
[[0;32;49mok[0m]: RESTORE can set an absolute expire
[[0;32;49mok[0m]: BLPOP, BRPOP: single existing list - linkedlist
[[0;32;49mok[0m]: RESTORE can set LRU
[[0;32;49mok[0m]: RESTORE can set LFU
[[0;32;49mok[0m]: INCR fails against a key holding a list
[[0;32;49mok[0m]: RESTORE returns an error of the key already exists
[[0;32;49mok[0m]: RESTORE can overwrite an existing key with REPLACE
[[0;32;49mok[0m]: DECRBY over 32bit value with over 32bit increment, negative res
[[0;32;49mok[0m]: RESTORE can detect a syntax error for unrecongized options
[[0;32;49mok[0m]: DUMP of non existing key returns nil
[[0;32;49mok[0m]: INCR uses shared objects in the 0-9999 range
[[0;32;49mok[0m]: BLPOP, BRPOP: multiple existing lists - linkedlist
[[0;32;49mok[0m]: DEL against a single item
[[0;32;49mok[0m]: INCR can modify objects in-place
[[0;32;49mok[0m]: Vararg DEL
[[0;32;49mok[0m]: KEYS with pattern
[[0;32;49mok[0m]: BLPOP, BRPOP: second list has an entry - linkedlist
[[0;32;49mok[0m]: KEYS to get all keys
[[0;32;49mok[0m]: DBSIZE
[[0;32;49mok[0m]: INCRBYFLOAT against non existing key
[[0;32;49mok[0m]: DEL all keys
[[0;32;49mok[0m]: INCRBYFLOAT against key originally set with SET
[[0;32;49mok[0m]: INCRBYFLOAT over 32bit value
[[0;32;49mok[0m]: INCRBYFLOAT over 32bit value with over 32bit increment
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (left)
[[0;32;49mok[0m]: BRPOPLPUSH - linkedlist
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (right)
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (both)
[[0;32;49mok[0m]: BLPOP, BRPOP: single existing list - ziplist
[[0;32;49mok[0m]: INCRBYFLOAT fails against a key holding a list
[[0;32;49mok[0m]: INCRBYFLOAT does not allow NaN or Infinity
[[0;32;49mok[0m]: INCRBYFLOAT decrement
[[0;32;49mok[0m]: string to double with null terminator
[[0;32;49mok[0m]: BLPOP, BRPOP: multiple existing lists - ziplist
[[0;32;49mok[0m]: BLPOP, BRPOP: second list has an entry - ziplist
[[0;32;49mok[0m]: BRPOPLPUSH - ziplist
[[0;32;49mok[0m]: SADD, SCARD, SISMEMBER, SMEMBERS basics - regular set
[[0;32;49mok[0m]: SADD, SCARD, SISMEMBER, SMEMBERS basics - intset
[[0;32;49mok[0m]: BLPOP, LPUSH + DEL should not awake blocked client
[[0;32;49mok[0m]: SADD against non set
[[0;32;49mok[0m]: SADD a non-integer against an intset
[[0;32;49mok[0m]: Explicit regression for a list bug
[[0;32;49mok[0m]: BLPOP, LPUSH + DEL + SET should not awake blocked client
[[0;32;49mok[0m]: SADD an integer larger than 64 bits
[[0;32;49mok[0m]: BLPOP with same key multiple times should work (issue #801)
[[0;32;49mok[0m]: MULTI/EXEC is isolated from the point of view of BLPOP
[[0;32;49mok[0m]: BLPOP with variadic LPUSH
[[0;32;49mok[0m]: SCAN basic
[[0;32;49mok[0m]: XADD can add entries into a stream that XRANGE can fetch
[[0;32;49mok[0m]: XADD IDs are incremental
[[0;32;49mok[0m]: XADD IDs are incremental when ms is the same as well
[[0;32;49mok[0m]: XADD IDs correctly report an error when overflowing
[[0;32;49mok[0m]: Check encoding - ziplist
[[0;32;49mok[0m]: ZSET basic ZADD and score update - ziplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZADD - ziplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZINCRBY
[[0;32;49mok[0m]: ZADD with options syntax error with incomplete pair
[[0;32;49mok[0m]: ZADD XX option without key - ziplist
[[0;32;49mok[0m]: ZADD XX existing key - ziplist
[[0;32;49mok[0m]: ZADD XX returns the number of elements actually added
[[0;32;49mok[0m]: ZADD XX updates existing elements score
[[0;32;49mok[0m]: ZADD XX and NX are not compatible
[[0;32;49mok[0m]: ZADD NX with non existing key
[[0;32;49mok[0m]: ZADD NX only add new elements without updating old ones
[[0;32;49mok[0m]: ZADD INCR works like ZINCRBY
[[0;32;49mok[0m]: ZADD INCR works with a single score-elemenet pair
[[0;32;49mok[0m]: ZADD CH option changes return value to all changed elements
[[0;32;49mok[0m]: ZINCRBY calls leading to NaN result in error
[[0;32;49mok[0m]: ZADD - Variadic version base case
[[0;32;49mok[0m]: ZADD - Return value is the number of actually added items
[[0;32;49mok[0m]: ZADD - Variadic version does not add nothing on single parsing err
[[0;32;49mok[0m]: ZADD - Variadic version will raise error on missing arg
[[0;32;49mok[0m]: ZINCRBY does not work variadic even if shares ZADD implementation
[[0;32;49mok[0m]: XGROUP CREATE: creation and duplicate group name detection
[[0;32;49mok[0m]: XGROUP CREATE: automatic stream creation fails without MKSTREAM
[[0;32;49mok[0m]: ZCARD basics - ziplist
[[0;32;49mok[0m]: XGROUP CREATE: automatic stream creation works with MKSTREAM
[[0;32;49mok[0m]: ZREM removes key after last element is removed
[[0;32;49mok[0m]: XREADGROUP will return only new elements
[[0;32;49mok[0m]: ZREM variadic version
[[0;32;49mok[0m]: XREADGROUP can read the history of the elements we own
[[0;32;49mok[0m]: XPENDING is able to return pending items
[[0;32;49mok[0m]: ZREM variadic version -- remove elements after key deletion
[[0;32;49mok[0m]: XPENDING can return single consumer items
[[0;32;49mok[0m]: XACK is able to remove items from the client/group PEL
[[0;32;49mok[0m]: XACK can't remove the same item multiple times
[[0;32;49mok[0m]: XACK is able to accept multiple arguments
[[0;32;49mok[0m]: PEL NACK reassignment after XGROUP SETID event
[[0;32;49mok[0m]: ZRANGE basics - ziplist
[[0;32;49mok[0m]: XREADGROUP will not report data on empty history. Bug #5577
[[0;32;49mok[0m]: XREADGROUP history reporting of deleted entries. Bug #5570
[[0;32;49mok[0m]: ZREVRANGE basics - ziplist
[[0;32;49mok[0m]: ZRANK/ZREVRANK basics - ziplist
[[0;32;49mok[0m]: SCAN COUNT
[[0;32;49mok[0m]: ZRANK - after deletion - ziplist
[[0;32;49mok[0m]: ZINCRBY - can create a new sorted set - ziplist
[[0;32;49mok[0m]: ZINCRBY - increment and decrement - ziplist
[[0;32;49mok[0m]: ZINCRBY return value
[[0;32;49mok[0m]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics
[[0;32;49mok[0m]: SADD overflows the maximum allowed integers in an intset
[[0;32;49mok[0m]: Variadic SADD
[[0;32;49mok[0m]: SCAN MATCH
[[0;32;49mok[0m]: SSCAN with encoding intset
[[0;32;49mok[0m]: ZRANGEBYSCORE with WITHSCORES
[[0;32;49mok[0m]: SSCAN with encoding hashtable
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT
[[0;32;49mok[0m]: HSCAN with encoding ziplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT and WITHSCORES
[[0;32;49mok[0m]: ZRANGEBYSCORE with non-value min or max
[[0;32;49mok[0m]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics
[[0;32;49mok[0m]: ZLEXCOUNT advanced
[[0;32;49mok[0m]: ZRANGEBYSLEX with LIMIT
[[0;32;49mok[0m]: ZRANGEBYLEX with invalid lex range specifiers
[[0;32;49mok[0m]: ZREMRANGEBYSCORE basics
[[0;32;49mok[0m]: ZREMRANGEBYSCORE with non-value min or max
[[0;32;49mok[0m]: ZREMRANGEBYRANK basics
[[0;32;49mok[0m]: ZUNIONSTORE against non-existing key doesn't set destination - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with empty set - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE basics - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with weights - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with a regular set and weights - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MIN - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MAX - ziplist
[[0;32;49mok[0m]: ZINTERSTORE basics - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with weights - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with a regular set and weights - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MIN - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MAX - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with +inf/-inf scores - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with NaN weights ziplist
[[0;32;49mok[0m]: ZINTERSTORE with +inf/-inf scores - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with NaN weights ziplist
[1/50 [0;33;49mdone[0m]: unit/printver (0 seconds)
[1;37;49mTesting unit/sort[0m
[[0;32;49mok[0m]: Basic ZPOP with a single key - ziplist
[[0;32;49mok[0m]: ZPOP with count - ziplist
[[0;32;49mok[0m]: BZPOP with a single existing sorted set - ziplist
[[0;32;49mok[0m]: XADD with MAXLEN option
[[0;32;49mok[0m]: BZPOP with multiple existing sorted sets - ziplist
[[0;32;49mok[0m]: BZPOP second sorted set has members - ziplist
[[0;32;49mok[0m]: Check encoding - skiplist
[[0;32;49mok[0m]: ZSET basic ZADD and score update - skiplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZADD - skiplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZINCRBY
[[0;32;49mok[0m]: ZADD with options syntax error with incomplete pair
[[0;32;49mok[0m]: ZADD XX option without key - skiplist
[[0;32;49mok[0m]: ZADD XX existing key - skiplist
[[0;32;49mok[0m]: Protocol desync regression test #1
[[0;32;49mok[0m]: ZADD XX returns the number of elements actually added
[[0;32;49mok[0m]: Very big payload in GET/SET
[[0;32;49mok[0m]: ZADD XX updates existing elements score
[[0;32;49mok[0m]: ZADD XX and NX are not compatible
[[0;32;49mok[0m]: ZADD NX with non existing key
[[0;32;49mok[0m]: ZADD NX only add new elements without updating old ones
[[0;32;49mok[0m]: ZADD INCR works like ZINCRBY
[[0;32;49mok[0m]: ZADD INCR works with a single score-elemenet pair
[[0;32;49mok[0m]: ZADD CH option changes return value to all changed elements
[[0;32;49mok[0m]: ZINCRBY calls leading to NaN result in error
[[0;32;49mok[0m]: ZADD - Variadic version base case
[[0;32;49mok[0m]: ZADD - Return value is the number of actually added items
[[0;32;49mok[0m]: ZADD - Variadic version does not add nothing on single parsing err
[[0;32;49mok[0m]: ZADD - Variadic version will raise error on missing arg
[[0;32;49mok[0m]: ZINCRBY does not work variadic even if shares ZADD implementation
[[0;32;49mok[0m]: ZCARD basics - skiplist
[[0;32;49mok[0m]: ZREM removes key after last element is removed
[[0;32;49mok[0m]: ZREM variadic version
[[0;32;49mok[0m]: ZREM variadic version -- remove elements after key deletion
[[0;32;49mok[0m]: ZRANGE basics - skiplist
[[0;32;49mok[0m]: HSCAN with encoding hashtable
[[0;32;49mok[0m]: ZSCAN with encoding ziplist
[[0;32;49mok[0m]: ZREVRANGE basics - skiplist
[[0;32;49mok[0m]: ZRANK/ZREVRANK basics - skiplist
[[0;32;49mok[0m]: ZRANK - after deletion - skiplist
[[0;32;49mok[0m]: ZINCRBY - can create a new sorted set - skiplist
[[0;32;49mok[0m]: ZINCRBY - increment and decrement - skiplist
[[0;32;49mok[0m]: Protocol desync regression test #2
[[0;32;49mok[0m]: ZINCRBY return value
[[0;32;49mok[0m]: HSET/HLEN - Big hash creation
[[0;32;49mok[0m]: Is the big hash encoded with an hash table?
[[0;32;49mok[0m]: HGET against the small hash
[[0;32;49mok[0m]: Regression for quicklist #3343 bug
[[0;32;49mok[0m]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics
[[0;32;49mok[0m]: ZRANGEBYSCORE with WITHSCORES
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT and WITHSCORES
[[0;32;49mok[0m]: ZRANGEBYSCORE with non-value min or max
[[0;32;49mok[0m]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics
[[0;32;49mok[0m]: ZLEXCOUNT advanced
[[0;32;49mok[0m]: ZRANGEBYSLEX with LIMIT
[[0;32;49mok[0m]: ZRANGEBYLEX with invalid lex range specifiers
[[0;32;49mok[0m]: ZREMRANGEBYSCORE basics
[[0;32;49mok[0m]: ZREMRANGEBYSCORE with non-value min or max
[[0;32;49mok[0m]: ZREMRANGEBYRANK basics
[[0;32;49mok[0m]: ZUNIONSTORE against non-existing key doesn't set destination - skiplist
[[0;32;49mok[0m]: Protocol desync regression test #3
[[0;32;49mok[0m]: ZUNIONSTORE with empty set - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE basics - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with weights - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with a regular set and weights - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MIN - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MAX - skiplist
[[0;32;49mok[0m]: ZINTERSTORE basics - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with weights - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with a regular set and weights - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MIN - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MAX - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with +inf/-inf scores - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with NaN weights skiplist
[[0;32;49mok[0m]: Set encoding after DEBUG RELOAD
[[0;32;49mok[0m]: SREM basics - regular set
[[0;32;49mok[0m]: ZINTERSTORE with +inf/-inf scores - skiplist
[[0;32;49mok[0m]: SREM basics - intset
[[0;32;49mok[0m]: ZINTERSTORE with NaN weights skiplist
[[0;32;49mok[0m]: SREM with multiple arguments
[[0;32;49mok[0m]: SREM variadic version with more args needed to destroy the key
[[0;32;49mok[0m]: Basic ZPOP with a single key - skiplist
[[0;32;49mok[0m]: ZPOP with count - skiplist
[[0;32;49mok[0m]: BZPOP with a single existing sorted set - skiplist
[[0;32;49mok[0m]: BZPOP with multiple existing sorted sets - skiplist
[[0;32;49mok[0m]: BZPOP second sorted set has members - skiplist
[[0;32;49mok[0m]: ZINTERSTORE regression with two sets, intset+hashtable
[[0;32;49mok[0m]: ZUNIONSTORE regression, should not create NaN in scores
[[0;32;49mok[0m]: ZINTERSTORE #516 regression, mixed sets and ziplist zsets
[[0;32;49mok[0m]: ZSCAN with encoding skiplist
[2/50 [0;33;49mdone[0m]: unit/type/incr (1 seconds)
[1;37;49mTesting unit/expire[0m
[[0;32;49mok[0m]: HGET against the big hash
[[0;32;49mok[0m]: HGET against non existing key
[[0;32;49mok[0m]: HSET in update and insert mode
[[0;32;49mok[0m]: HSETNX target key missing - small hash
[[0;32;49mok[0m]: HSETNX target key exists - small hash
[[0;32;49mok[0m]: HSETNX target key missing - big hash
[[0;32;49mok[0m]: HSETNX target key exists - big hash
[[0;32;49mok[0m]: HMSET wrong number of args
[[0;32;49mok[0m]: HMSET - small hash
[[0;32;49mok[0m]: SCAN guarantees check under write load
[[0;32;49mok[0m]: Generated sets must be encoded as hashtable
[[0;32;49mok[0m]: SINTER with two sets - hashtable
[[0;32;49mok[0m]: SSCAN with integer encoded object (issue #1345)
[[0;32;49mok[0m]: SINTERSTORE with two sets - hashtable
[[0;32;49mok[0m]: SSCAN with PATTERN
[[0;32;49mok[0m]: HSCAN with PATTERN
[[0;32;49mok[0m]: ZSCAN with PATTERN
[[0;32;49mok[0m]: SINTERSTORE with two sets, after a DEBUG RELOAD - hashtable
[[0;32;49mok[0m]: HMSET - big hash
[[0;32;49mok[0m]: HMGET against non existing key and fields
[[0;32;49mok[0m]: HMGET against wrong type
[[0;32;49mok[0m]: HMGET - small hash
[[0;32;49mok[0m]: SUNION with two sets - hashtable
[[0;32;49mok[0m]: AUTH fails when a wrong password is given
[[0;32;49mok[0m]: Arbitrary command gives an error when AUTH is required
[[0;32;49mok[0m]: AUTH succeeds when the right password is given
[[0;32;49mok[0m]: Once AUTH succeeded we can actually send commands to the server
[[0;32;49mok[0m]: SUNIONSTORE with two sets - hashtable
[[0;32;49mok[0m]: Old Ziplist: SORT BY key
[[0;32;49mok[0m]: Old Ziplist: SORT BY key with limit
[[0;32;49mok[0m]: Old Ziplist: SORT BY hash field
[[0;32;49mok[0m]: SINTER against three sets - hashtable
[[0;32;49mok[0m]: SINTERSTORE with three sets - hashtable
[[0;32;49mok[0m]: SUNION with non existing keys - hashtable
[[0;32;49mok[0m]: SDIFF with two sets - hashtable
[[0;32;49mok[0m]: SDIFF with three sets - hashtable
[[0;32;49mok[0m]: SDIFFSTORE with three sets - hashtable
[[0;32;49mok[0m]: ZSCAN scores: regression test for issue #2175
[[0;32;49mok[0m]: ZUNIONSTORE result is sorted
[[0;32;49mok[0m]: ZSET commands don't accept the empty strings as valid score
[[0;32;49mok[0m]: HMGET - big hash
[[0;32;49mok[0m]: MIGRATE is caching connections
[[0;32;49mok[0m]: HKEYS - small hash
[[0;32;49mok[0m]: Generated sets must be encoded as intset
[[0;32;49mok[0m]: SINTER with two sets - intset
[[0;32;49mok[0m]: SINTERSTORE with two sets - intset
[[0;32;49mok[0m]: HKEYS - big hash
[[0;32;49mok[0m]: HVALS - small hash
[[0;32;49mok[0m]: SINTERSTORE with two sets, after a DEBUG RELOAD - intset
[[0;32;49mok[0m]: SUNION with two sets - intset
[[0;32;49mok[0m]: HVALS - big hash
[[0;32;49mok[0m]: HGETALL - small hash
[[0;32;49mok[0m]: ZSCORE - ziplist
[[0;32;49mok[0m]: SUNIONSTORE with two sets - intset
[[0;32;49mok[0m]: SINTER against three sets - intset
[[0;32;49mok[0m]: SINTERSTORE with three sets - intset
[[0;32;49mok[0m]: SUNION with non existing keys - intset
[[0;32;49mok[0m]: SDIFF with two sets - intset
[[0;32;49mok[0m]: SDIFF with three sets - intset
[[0;32;49mok[0m]: SDIFFSTORE with three sets - intset
[[0;32;49mok[0m]: SDIFF with first set empty
[[0;32;49mok[0m]: SDIFF with same set two times
[[0;32;49mok[0m]: HGETALL - big hash
[[0;32;49mok[0m]: HDEL and return value
[[0;32;49mok[0m]: HDEL - more than a single value
[[0;32;49mok[0m]: HDEL - hash becomes empty before deleting all specified fields
[[0;32;49mok[0m]: HEXISTS
[[0;32;49mok[0m]: Is a ziplist encoded Hash promoted on big payload?
[[0;32;49mok[0m]: HINCRBY against non existing database key
[[0;32;49mok[0m]: HINCRBY against non existing hash key
[[0;32;49mok[0m]: HINCRBY against hash key created by hincrby itself
[[0;32;49mok[0m]: HINCRBY against hash key originally set with HSET
[[0;32;49mok[0m]: HINCRBY over 32bit value
[[0;32;49mok[0m]: HINCRBY over 32bit value with over 32bit increment
[[0;32;49mok[0m]: HINCRBY fails against hash value with spaces (left)
[[0;32;49mok[0m]: HINCRBY fails against hash value with spaces (right)
[[0;32;49mok[0m]: EXPIRE - set timeouts multiple times
[[0;32;49mok[0m]: HINCRBY can detect overflows
[[0;32;49mok[0m]: EXPIRE - It should be still possible to read 'x'
[[0;32;49mok[0m]: HINCRBYFLOAT against non existing database key
[[0;32;49mok[0m]: ZSCORE after a DEBUG RELOAD - ziplist
[[0;32;49mok[0m]: HINCRBYFLOAT against non existing hash key
[[0;32;49mok[0m]: HINCRBYFLOAT against hash key created by hincrby itself
[[0;32;49mok[0m]: HINCRBYFLOAT against hash key originally set with HSET
[[0;32;49mok[0m]: HINCRBYFLOAT over 32bit value
[[0;32;49mok[0m]: HINCRBYFLOAT over 32bit value with over 32bit increment
[[0;32;49mok[0m]: HINCRBYFLOAT fails against hash value with spaces (left)
[[0;32;49mok[0m]: HINCRBYFLOAT fails against hash value with spaces (right)
[[0;32;49mok[0m]: HSTRLEN against the small hash
[3/50 [0;33;49mdone[0m]: unit/auth (1 seconds)
[1;37;49mTesting unit/other[0m
[[0;32;49mok[0m]: ZSET sorting stresser - ziplist
[[0;32;49mok[0m]: HSTRLEN against the big hash
[[0;32;49mok[0m]: HSTRLEN against non existing field
[[0;32;49mok[0m]: HSTRLEN corner cases
[[0;32;49mok[0m]: Hash ziplist regression test for large keys
[[0;32;49mok[0m]: Hash fuzzing #1 - 10 fields
[[0;32;49mok[0m]: Regression for a crash with blocking ops and pipelining
[[0;32;49mok[0m]: Hash fuzzing #2 - 10 fields
[[0;32;49mok[0m]: Old Linked list: SORT BY key
[[0;32;49mok[0m]: Old Linked list: SORT BY key with limit
[[0;32;49mok[0m]: Old Linked list: SORT BY hash field
[[0;32;49mok[0m]: SAVE - make sure there are all the types as values
[4/50 [0;33;49mdone[0m]: unit/protocol (1 seconds)
[1;37;49mTesting unit/multi[0m
[[0;32;49mok[0m]: XCLAIM can claim PEL items from another consumer
[[0;32;49mok[0m]: MUTLI / EXEC basics
[[0;32;49mok[0m]: DISCARD
[[0;32;49mok[0m]: Nested MULTI are not allowed
[[0;32;49mok[0m]: MULTI where commands alter argc/argv
[[0;32;49mok[0m]: WATCH inside MULTI is not allowed
[[0;32;49mok[0m]: EXEC fails if there are errors while queueing commands #1
[[0;32;49mok[0m]: EXEC fails if there are errors while queueing commands #2
[[0;32;49mok[0m]: If EXEC aborts, the client MULTI state is cleared
[[0;32;49mok[0m]: EXEC works on WATCHed key not modified
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified (1 key of 1 watched)
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified (1 key of 5 watched)
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified by SORT with STORE even if the result is empty
[[0;32;49mok[0m]: After successful EXEC key is no longer watched
[[0;32;49mok[0m]: After failed EXEC key is no longer watched
[[0;32;49mok[0m]: It is possible to UNWATCH
[[0;32;49mok[0m]: UNWATCH when there is nothing watched works as expected
[[0;32;49mok[0m]: FLUSHALL is able to touch the watched keys
[[0;32;49mok[0m]: FLUSHALL does not touch non affected keys
[[0;32;49mok[0m]: FLUSHDB is able to touch the watched keys
[[0;32;49mok[0m]: FLUSHDB does not touch non affected keys
[[0;32;49mok[0m]: WATCH is able to remember the DB a key belongs to
[[0;32;49mok[0m]: WATCH will consider touched keys target of EXPIRE
[[0;32;49mok[0m]: FUZZ stresser with data model binary
[[0;32;49mok[0m]: BRPOPLPUSH with zero timeout should block indefinitely
[[0;32;49mok[0m]: XCLAIM without JUSTID increments delivery count
[[0;32;49mok[0m]: DEL against expired key
[[0;32;49mok[0m]: EXISTS
[[0;32;49mok[0m]: Zero length value in key. SET/GET/EXISTS
[[0;32;49mok[0m]: Commands pipelining
[[0;32;49mok[0m]: Non existing command
[[0;32;49mok[0m]: RENAME basic usage
[[0;32;49mok[0m]: RENAME source key should no longer exist
[[0;32;49mok[0m]: RENAME against already existing key
[[0;32;49mok[0m]: RENAMENX basic usage
[[0;32;49mok[0m]: RENAMENX against already existing key
[[0;32;49mok[0m]: RENAMENX against already existing key (2)
[[0;32;49mok[0m]: RENAME against non existing source key
[[0;32;49mok[0m]: RENAME where source and dest key are the same (existing)
[[0;32;49mok[0m]: RENAMENX where source and dest key are the same (existing)
[[0;32;49mok[0m]: RENAME where source and dest key are the same (non existing)
[[0;32;49mok[0m]: RENAME with volatile key, should move the TTL as well
[[0;32;49mok[0m]: RENAME with volatile key, should not inherit TTL of target key
[[0;32;49mok[0m]: DEL all keys again (DB 0)
[[0;32;49mok[0m]: DEL all keys again (DB 1)
[[0;32;49mok[0m]: MOVE basic usage
[[0;32;49mok[0m]: MOVE against key existing in the target DB
[[0;32;49mok[0m]: MOVE against non-integer DB (#1428)
[[0;32;49mok[0m]: MOVE can move key expire metadata as well
[[0;32;49mok[0m]: MOVE does not create an expire if it does not exist
[[0;32;49mok[0m]: SET/GET keys in different DBs
[[0;32;49mok[0m]: RANDOMKEY
[[0;32;49mok[0m]: RANDOMKEY against empty DB
[[0;32;49mok[0m]: RANDOMKEY regression 1
[[0;32;49mok[0m]: KEYS * two times with long key, Github issue #1208
[5/50 [0;33;49mdone[0m]: unit/keyspace (2 seconds)
[1;37;49mTesting unit/quit[0m
[[0;32;49mok[0m]: FUZZ stresser with data model alpha
[[0;32;49mok[0m]: QUIT returns OK
[[0;32;49mok[0m]: Pipelined commands after QUIT must not be executed
[[0;32;49mok[0m]: Pipelined commands after QUIT that exceed read buffer size
[6/50 [0;33;49mdone[0m]: unit/quit (0 seconds)
[1;37;49mTesting unit/aofrw[0m
[[0;32;49mok[0m]: Hash fuzzing #1 - 512 fields
[[0;32;49mok[0m]: WATCH will not consider touched expired keys
[[0;32;49mok[0m]: DISCARD should clear the WATCH dirty flag on the client
[[0;32;49mok[0m]: DISCARD should UNWATCH all the keys
[[0;32;49mok[0m]: XADD mass insertion and XLEN
[[0;32;49mok[0m]: XADD with ID 0-0
[[0;32;49mok[0m]: XRANGE COUNT works as expected
[[0;32;49mok[0m]: XREVRANGE COUNT works as expected
[[0;32;49mok[0m]: Very big payload random access
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (single write command)
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (empty transaction)
[[0;32;49mok[0m]: BRPOPLPUSH with a client BLPOPing the target list
[[0;32;49mok[0m]: BRPOPLPUSH with wrong source type
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (read-only commands)
[[0;32;49mok[0m]: Consumer group last ID propagation to slave (NOACK=0)
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (write command, no effect)
[[0;32;49mok[0m]: XRANGE can be used to iterate the whole stream
[7/50 [0;33;49mdone[0m]: unit/multi (2 seconds)
[1;37;49mTesting integration/block-repl[0m
[[0;32;49mok[0m]: EXPIRE - After 2.1 seconds the key should no longer be here
[[0;32;49mok[0m]: EXPIRE - write on expire should work
[[0;32;49mok[0m]: EXPIREAT - Check for EXPIRE alike behavior
[[0;32;49mok[0m]: SETEX - Set + Expire combo operation. Check for TTL
[[0;32;49mok[0m]: SETEX - Check value
[[0;32;49mok[0m]: SETEX - Overwrite old key
[[0;32;49mok[0m]: FUZZ stresser with data model compr
[[0;32;49mok[0m]: Hash fuzzing #2 - 512 fields
[[0;32;49mok[0m]: ZRANGEBYSCORE fuzzy test, 100 ranges in 128 element sorted set - ziplist
[[0;32;49mok[0m]: Old Big Linked list: SORT BY key
[[0;32;49mok[0m]: Old Big Linked list: SORT BY key with limit
[[0;32;49mok[0m]: BRPOPLPUSH with wrong destination type
[[0;32;49mok[0m]: BRPOPLPUSH maintains order of elements after failure
[[0;32;49mok[0m]: BRPOPLPUSH with multiple blocked clients
[[0;32;49mok[0m]: Linked BRPOPLPUSH
[[0;32;49mok[0m]: Circular BRPOPLPUSH
[[0;32;49mok[0m]: Self-referential BRPOPLPUSH
[[0;32;49mok[0m]: BRPOPLPUSH inside a transaction
[[0;32;49mok[0m]: PUSH resulting from BRPOPLPUSH affect WATCH
[[0;32;49mok[0m]: BRPOPLPUSH does not affect WATCH while still blocked
[[0;32;49mok[0m]: ZRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist
[[0;32;49mok[0m]: Consumer group last ID propagation to slave (NOACK=1)
[[0;32;49mok[0m]: SET 10000 numeric keys and access all them in reverse order
[[0;32;49mok[0m]: DBSIZE should be 10000 now
[[0;32;49mok[0m]: SETNX target key missing
[[0;32;49mok[0m]: SETNX target key exists
[[0;32;49mok[0m]: SETNX against not-expired volatile key
[[0;32;49mok[0m]: BGSAVE
[[0;32;49mok[0m]: SELECT an out of range DB
[8/50 [0;33;49mdone[0m]: unit/type/stream-cgroups (4 seconds)
[1;37;49mTesting integration/replication[0m
[[0;32;49mok[0m]: SETEX - Wait for the key to expire
[[0;32;49mok[0m]: SETEX - Wrong time parameter
[[0;32;49mok[0m]: PERSIST can undo an EXPIRE
[[0;32;49mok[0m]: PERSIST returns 0 against non existing or non volatile keys
[[0;32;49mok[0m]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist
[[0;32;49mok[0m]: ZSETs skiplist implementation backlink consistency test - ziplist
[[0;32;49mok[0m]: Old Big Linked list: SORT BY hash field
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: Intset: SORT BY key
[[0;32;49mok[0m]: Intset: SORT BY key with limit
[[0;32;49mok[0m]: Intset: SORT BY hash field
[[0;32;49mok[0m]: XREVRANGE returns the reverse of XRANGE
[[0;32;49mok[0m]: XREAD with non empty stream
[[0;32;49mok[0m]: Non blocking XREAD with empty streams
[[0;32;49mok[0m]: XREAD with non empty second stream
[[0;32;49mok[0m]: Blocking XREAD waiting new data
[[0;32;49mok[0m]: Blocking XREAD waiting old data
[[0;32;49mok[0m]: XREAD: XADD + DEL should not awake client
[[0;32;49mok[0m]: XREAD: XADD + DEL + LPUSH should not awake client
[[0;32;49mok[0m]: XREAD with same stream name multiple times should work
[[0;32;49mok[0m]: XREAD + multiple XADD inside transaction
[[0;32;49mok[0m]: XDEL basic test
[[0;32;49mok[0m]: Hash table: SORT BY key
[[0;32;49mok[0m]: Hash table: SORT BY key with limit
[[0;32;49mok[0m]: Hash table: SORT BY hash field
[[0;32;49mok[0m]: SDIFF fuzzing
[[0;32;49mok[0m]: SINTER against non-set should throw error
[[0;32;49mok[0m]: SUNION against non-set should throw error
[[0;32;49mok[0m]: SINTER should handle non existing key as empty
[[0;32;49mok[0m]: SINTER with same integer elements but different encoding
[[0;32;49mok[0m]: SINTERSTORE against non existing keys should delete dstkey
[[0;32;49mok[0m]: SUNIONSTORE against non existing keys should delete dstkey
[[0;32;49mok[0m]: SPOP basics - hashtable
[[0;32;49mok[0m]: SPOP with <count>=1 - hashtable
[[0;32;49mok[0m]: SRANDMEMBER - hashtable
[[0;32;49mok[0m]: SPOP basics - intset
[[0;32;49mok[0m]: SPOP with <count>=1 - intset
[[0;32;49mok[0m]: SRANDMEMBER - intset
[[0;32;49mok[0m]: SPOP with <count>
[[0;32;49mok[0m]: SPOP with <count>
[[0;32;49mok[0m]: SPOP using integers, testing Knuth's and Floyd's algorithm
[[0;32;49mok[0m]: SPOP using integers with Knuth's algorithm
[[0;32;49mok[0m]: SPOP new implementation: code path #1
[[0;32;49mok[0m]: SPOP new implementation: code path #2
[[0;32;49mok[0m]: SPOP new implementation: code path #3
[[0;32;49mok[0m]: SRANDMEMBER with <count> against non existing key
[[0;32;49mok[0m]: SRANDMEMBER with <count> - hashtable
[[0;32;49mok[0m]: SRANDMEMBER with <count> - intset
[[0;32;49mok[0m]: SMOVE basics - from regular set to intset
[[0;32;49mok[0m]: SMOVE basics - from intset to regular set
[[0;32;49mok[0m]: SMOVE non existing key
[[0;32;49mok[0m]: SMOVE non existing src set
[[0;32;49mok[0m]: SMOVE from regular set to non existing destination set
[[0;32;49mok[0m]: SMOVE from intset to non existing destination set
[[0;32;49mok[0m]: SMOVE wrong src key type
[[0;32;49mok[0m]: SMOVE wrong dst key type
[[0;32;49mok[0m]: SMOVE with identical source and destination
[[0;32;49mok[0m]: EXPIRES after a reload (snapshot + append only file rewrite)
[[0;32;49mok[0m]: Stress test the hash ziplist -> hashtable encoding conversion
[[0;32;49mok[0m]: Test HINCRBYFLOAT for correct float representation (issue #2846)
[9/50 [0;33;49mdone[0m]: unit/type/hash (5 seconds)
[1;37;49mTesting integration/replication-2[0m
[[0;32;49mok[0m]: ZSETs ZRANK augmented skip list stress testing - ziplist
[[0;32;49mok[0m]: BZPOPMIN, ZADD + DEL should not awake blocked client
[[0;32;49mok[0m]: BZPOPMIN, ZADD + DEL + SET should not awake blocked client
[[0;32;49mok[0m]: BZPOPMIN with same key multiple times should work
[[0;32;49mok[0m]: MULTI/EXEC is isolated from the point of view of BZPOPMIN
[[0;32;49mok[0m]: BZPOPMIN with variadic ZADD
[[0;32;49mok[0m]: Slave enters handshake
[[0;32;49mok[0m]: BRPOPLPUSH timeout
[[0;32;49mok[0m]: BLPOP when new key is moved into place
[[0;32;49mok[0m]: BLPOP when result key is created by SORT..STORE
[[0;32;49mok[0m]: BLPOP: with single empty list argument
[[0;32;49mok[0m]: BLPOP: with negative timeout
[[0;32;49mok[0m]: BLPOP: with non-integer timeout
[[0;32;49mok[0m]: EXPIRE pricision is now the millisecond
[[0;32;49mok[0m]: BZPOPMIN with zero timeout should block indefinitely
[[0;32;49mok[0m]: ZSCORE - skiplist
[[0;32;49mok[0m]: ZSCORE after a DEBUG RELOAD - skiplist
[[0;32;49mok[0m]: XDEL fuzz test
[[0;32;49mok[0m]: ZSET sorting stresser - skiplist
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: If min-slaves-to-write is honored, write is accepted
[[0;32;49mok[0m]: No write if min-slaves-to-write is < attached slaves
[[0;32;49mok[0m]: If min-slaves-to-write is honored, write is accepted (again)
[[0;32;49mok[0m]: BLPOP: with zero timeout should block indefinitely
[[0;32;49mok[0m]: BLPOP: second argument is not a list
[[0;32;49mok[0m]: SETNX against expired volatile key
[[0;32;49mok[0m]: MGET
[[0;32;49mok[0m]: MGET against non existing key
[[0;32;49mok[0m]: MGET against non-string key
[[0;32;49mok[0m]: GETSET (set new value)
[[0;32;49mok[0m]: GETSET (replace old value)
[[0;32;49mok[0m]: MSET base case
[[0;32;49mok[0m]: MSET wrong number of args
[[0;32;49mok[0m]: MSETNX with already existent key
[[0;32;49mok[0m]: MSETNX with not existing keys
[[0;32;49mok[0m]: STRLEN against non-existing key
[[0;32;49mok[0m]: STRLEN against integer-encoded value
[[0;32;49mok[0m]: STRLEN against plain string
[[0;32;49mok[0m]: SETBIT against non-existing key
[[0;32;49mok[0m]: SETBIT against string-encoded key
[[0;32;49mok[0m]: SETBIT against integer-encoded key
[[0;32;49mok[0m]: SETBIT against key with wrong type
[[0;32;49mok[0m]: SETBIT with out of range bit offset
[[0;32;49mok[0m]: SETBIT with non-bit argument
[[0;32;49mok[0m]: intsets implementation stress testing
[10/50 [0;33;49mdone[0m]: unit/type/set (7 seconds)
[1;37;49mTesting integration/replication-3[0m
[[0;32;49mok[0m]: SETBIT fuzzing
[[0;32;49mok[0m]: GETBIT against non-existing key
[[0;32;49mok[0m]: GETBIT against string-encoded key
[[0;32;49mok[0m]: GETBIT against integer-encoded key
[[0;32;49mok[0m]: SETRANGE against non-existing key
[[0;32;49mok[0m]: SETRANGE against string-encoded key
[[0;32;49mok[0m]: SETRANGE against integer-encoded key
[[0;32;49mok[0m]: SETRANGE against key with wrong type
[[0;32;49mok[0m]: SETRANGE with out of range offset
[[0;32;49mok[0m]: GETRANGE against non-existing key
[[0;32;49mok[0m]: GETRANGE against string value
[[0;32;49mok[0m]: GETRANGE against integer-encoded value
[[0;32;49mok[0m]: LTRIM stress testing - linkedlist
[[0;32;49mok[0m]: Big Hash table: SORT BY key
[[0;32;49mok[0m]: Big Hash table: SORT BY key with limit
[[0;32;49mok[0m]: PEXPIRE/PSETEX/PEXPIREAT can set sub-second expires
[[0;32;49mok[0m]: TTL returns time to live in seconds
[[0;32;49mok[0m]: PTTL returns time to live in milliseconds
[[0;32;49mok[0m]: TTL / PTTL return -1 if key has no expire
[[0;32;49mok[0m]: TTL / PTTL return -2 if key does not exit
[[0;32;49mok[0m]: EXPIRES after AOF reload (without rewrite)
[[0;32;49mok[0m]: Big Hash table: SORT BY hash field
[[0;32;49mok[0m]: SORT GET #
[[0;32;49mok[0m]: SORT GET <const>
[[0;32;49mok[0m]: SORT GET (key and hash) with sanity check
[[0;32;49mok[0m]: SORT BY key STORE
[[0;32;49mok[0m]: SORT BY hash field STORE
[[0;32;49mok[0m]: SORT extracts STORE correctly
[[0;32;49mok[0m]: SORT extracts multiple STORE correctly
[[0;32;49mok[0m]: SORT DESC
[[0;32;49mok[0m]: SORT ALPHA against integer encoded strings
[[0;32;49mok[0m]: SORT sorted set
[[0;32;49mok[0m]: SORT sorted set BY nosort should retain ordering
[[0;32;49mok[0m]: SORT sorted set BY nosort + LIMIT
[[0;32;49mok[0m]: SORT sorted set BY nosort works as expected from scripts
[[0;32;49mok[0m]: SORT sorted set: +inf and -inf handling
[[0;32;49mok[0m]: SORT regression for issue #19, sorting floats
[[0;32;49mok[0m]: SORT with STORE returns zero if result is empty (github issue 224)
[[0;32;49mok[0m]: SORT with STORE does not create empty lists (github issue 224)
[[0;32;49mok[0m]: SORT with STORE removes key if result is empty (github issue 227)
[[0;32;49mok[0m]: SORT with BY <constant> and STORE should still order output
[[0;32;49mok[0m]: SORT will complain with numerical sorting and bad doubles (1)
[[0;32;49mok[0m]: SORT will complain with numerical sorting and bad doubles (2)
[[0;32;49mok[0m]: SORT BY sub-sorts lexicographically if score is the same
[[0;32;49mok[0m]: SORT GET with pattern ending with just -> does not get hash field
[[0;32;49mok[0m]: SORT by nosort retains native order for lists
[[0;32;49mok[0m]: SORT by nosort plus store retains native order for lists
[[0;32;49mok[0m]: SORT by nosort with limit returns based on original list order
[[0;32;49mok[0m]: SORT speed, 100 element list BY key, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list BY hash field, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list directly, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list BY <const>, 100 times
[[0;32;49mok[0m]: BLPOP: timeout
[[0;32;49mok[0m]: BLPOP: arguments are empty
[[0;32;49mok[0m]: BRPOP: with single empty list argument
[[0;32;49mok[0m]: BRPOP: with negative timeout
[[0;32;49mok[0m]: BRPOP: with non-integer timeout
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: SCAN regression test for issue #4906
[[0;32;49mok[0m]: ZRANGEBYSCORE fuzzy test, 100 ranges in 100 element sorted set - skiplist
[11/50 [0;33;49mdone[0m]: unit/sort (8 seconds)
[1;37;49mTesting integration/replication-4[0m
[[0;32;49mok[0m]: ZRANGEBYLEX fuzzy test, 100 ranges in 100 element sorted set - skiplist
[12/50 [0;33;49mdone[0m]: unit/scan (8 seconds)
[1;37;49mTesting integration/replication-psync[0m
[[0;32;49mok[0m]: GETRANGE fuzzing
[[0;32;49mok[0m]: Extended SET can detect syntax errors
[[0;32;49mok[0m]: Extended SET NX option
[[0;32;49mok[0m]: Extended SET XX option
[[0;32;49mok[0m]: Extended SET EX option
[[0;32;49mok[0m]: Extended SET PX option
[[0;32;49mok[0m]: Extended SET using multiple options at once
[[0;32;49mok[0m]: GETRANGE with huge ranges, Github issue #1844
[[0;32;49mok[0m]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 100 element sorted set - skiplist
[[0;32;49mok[0m]: ZSETs skiplist implementation backlink consistency test - skiplist
[[0;32;49mok[0m]: Redis should actively expire keys incrementally
[13/50 [0;33;49mdone[0m]: unit/type/string (9 seconds)
[1;37;49mTesting integration/aof[0m
[[0;32;49mok[0m]: Unfinished MULTI: Server should start if load-truncated is yes
[[0;32;49mok[0m]: BRPOP: with zero timeout should block indefinitely
[[0;32;49mok[0m]: BRPOP: second argument is not a list
[[0;32;49mok[0m]: PIPELINING stresser (also a regression for the old epoll bug)
[[0;32;49mok[0m]: APPEND basics
[[0;32;49mok[0m]: APPEND basics, integer encoded values
[[0;32;49mok[0m]: ZSETs ZRANK augmented skip list stress testing - skiplist
[[0;32;49mok[0m]: BZPOPMIN, ZADD + DEL should not awake blocked client
[[0;32;49mok[0m]: BZPOPMIN, ZADD + DEL + SET should not awake blocked client
[[0;32;49mok[0m]: BZPOPMIN with same key multiple times should work
[[0;32;49mok[0m]: MULTI/EXEC is isolated from the point of view of BZPOPMIN
[[0;32;49mok[0m]: BZPOPMIN with variadic ZADD
[[0;32;49mok[0m]: Short read: Server should start if load-truncated is yes
[[0;32;49mok[0m]: Truncated AOF loaded: we expect foo to be equal to 5
[[0;32;49mok[0m]: Append a new command after loading an incomplete AOF
[[0;32;49mok[0m]: APPEND fuzzing
[[0;32;49mok[0m]: FLUSHDB
[[0;32;49mok[0m]: Perform a final SAVE to leave a clean DB on disk
[14/50 [0;33;49mdone[0m]: unit/other (9 seconds)
[1;37;49mTesting integration/rdb[0m
[[0;32;49mok[0m]: Short read + command: Server should start
[[0;32;49mok[0m]: Truncated AOF loaded: we expect foo to be equal to 6 now
[[0;32;49mok[0m]: Redis should lazy expire keys
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: RDB encoding loading test
[[0;32;49mok[0m]: Test replication partial resync: no reconnection, just sync (diskless: no, reconnect: 0)
[[0;32;49mok[0m]: Bad format: Server should have logged an error
[[0;32;49mok[0m]: Unfinished MULTI: Server should have logged an error
[[0;32;49mok[0m]: Server started empty with non-existing RDB file
[[0;32;49mok[0m]: Short read: Server should have logged an error
[[0;32;49mok[0m]: Short read: Utility should confirm the AOF is not valid
[[0;32;49mok[0m]: Short read: Utility should be able to fix the AOF
[[0;32;49mok[0m]: BZPOPMIN with zero timeout should block indefinitely
[[0;32;49mok[0m]: Server started empty with empty RDB file
[[0;32;49mok[0m]: Fixed AOF: Server should have been started
[[0;32;49mok[0m]: Fixed AOF: Keyspace should contain values that were parseable
[[0;32;49mok[0m]: AOF+SPOP: Server should have been started
[[0;32;49mok[0m]: AOF+SPOP: Set should have 1 member
[[0;32;49mok[0m]: Test RDB stream encoding
[[0;32;49mok[0m]: EXPIRE should not resurrect keys (issue #1026)
[[0;32;49mok[0m]: 5 keys in, 5 keys out
[[0;32;49mok[0m]: EXPIRE with empty string as TTL should report an error
[[0;32;49mok[0m]: AOF+SPOP: Server should have been started
[[0;32;49mok[0m]: AOF+SPOP: Set should have 1 member
[[0;32;49mok[0m]: Server should not start if RDB file can't be open
[[0;32;49mok[0m]: BRPOP: timeout
[[0;32;49mok[0m]: BRPOP: arguments are empty
[[0;32;49mok[0m]: BLPOP inside a transaction
[[0;32;49mok[0m]: LPUSHX, RPUSHX - generic
[[0;32;49mok[0m]: LPUSHX, RPUSHX - linkedlist
[[0;32;49mok[0m]: LINSERT - linkedlist
[[0;32;49mok[0m]: LPUSHX, RPUSHX - ziplist
[[0;32;49mok[0m]: LINSERT - ziplist
[[0;32;49mok[0m]: LINSERT raise error on bad syntax
[[0;32;49mok[0m]: ZSET skiplist order consistency when elements are moved
[[0;32;49mok[0m]: LINDEX consistency test - quicklist
[[0;32;49mok[0m]: AOF+EXPIRE: Server should have been started
[[0;32;49mok[0m]: AOF+EXPIRE: List should be empty
[[0;32;49mok[0m]: Server should not start if RDB is corrupted
[[0;32;49mok[0m]: LINDEX random access - quicklist
[15/50 [0;33;49mdone[0m]: unit/type/zset (11 seconds)
[1;37;49mTesting integration/convert-zipmap-hash-on-load[0m
[16/50 [0;33;49mdone[0m]: integration/rdb (1 seconds)
[1;37;49mTesting integration/logging[0m
[[0;32;49mok[0m]: Check if list is still ok after a DEBUG RELOAD - quicklist
[[0;32;49mok[0m]: RDB load zipmap hash: converts to ziplist
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: LINDEX consistency test - quicklist
[[0;32;49mok[0m]: Redis should not try to convert DEL into EXPIREAT for EXPIRE -1
[[0;32;49mok[0m]: LINDEX random access - quicklist
[17/50 [0;33;49mdone[0m]: integration/aof (3 seconds)
[1;37;49mTesting integration/psync2[0m
[[0;32;49mok[0m]: Server is able to generate a stack trace on selected systems
[[0;32;49mok[0m]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-entries is exceeded
[18/50 [0;33;49mdone[0m]: integration/logging (1 seconds)
[1;37;49mTesting integration/psync2-reg[0m
[[0;32;49mok[0m]: Check if list is still ok after a DEBUG RELOAD - quicklist
[[0;32;49mok[0m]: LLEN against non-list value error
[[0;32;49mok[0m]: LLEN against non existing key
[[0;32;49mok[0m]: LINDEX against non-list value error
[[0;32;49mok[0m]: LINDEX against non existing key
[[0;32;49mok[0m]: LPUSH against non-list value error
[[0;32;49mok[0m]: RPUSH against non-list value error
[[0;32;49mok[0m]: RPOPLPUSH base case - linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: RPOPLPUSH base case - ziplist
[[0;32;49mok[0m]: RPOPLPUSH with the same list as src and dst - ziplist
[[0;32;49mok[0m]: RPOPLPUSH with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with ziplist source and existing target ziplist
[[0;32;49mok[0m]: RPOPLPUSH against non existing key
[[0;32;49mok[0m]: RPOPLPUSH against non list src key
[[0;32;49mok[0m]: RPOPLPUSH against non list dst key
[[0;32;49mok[0m]: RPOPLPUSH against non existing src key
[[0;32;49mok[0m]: Basic LPOP/RPOP - linkedlist
[[0;32;49mok[0m]: Basic LPOP/RPOP - ziplist
[[0;32;49mok[0m]: LPOP/RPOP against non list value
[[0;32;49mok[0m]: Mass RPOP/LPOP - quicklist
[[0;32;49mok[0m]: Mass RPOP/LPOP - quicklist
[[0;32;49mok[0m]: LRANGE basics - linkedlist
[[0;32;49mok[0m]: LRANGE inverted indexes - linkedlist
[[0;32;49mok[0m]: LRANGE out of range indexes including the full list - linkedlist
[[0;32;49mok[0m]: LRANGE out of range negative end index - linkedlist
[[0;32;49mok[0m]: LRANGE basics - ziplist
[[0;32;49mok[0m]: LRANGE inverted indexes - ziplist
[[0;32;49mok[0m]: LRANGE out of range indexes including the full list - ziplist
[[0;32;49mok[0m]: LRANGE out of range negative end index - ziplist
[[0;32;49mok[0m]: LRANGE against non existing key
[[0;32;49mok[0m]: LTRIM basics - linkedlist
[[0;32;49mok[0m]: LTRIM out of range negative end index - linkedlist
[[0;32;49mok[0m]: LTRIM basics - ziplist
[[0;32;49mok[0m]: LTRIM out of range negative end index - ziplist
[[0;32;49mok[0m]: LSET - linkedlist
[[0;32;49mok[0m]: LSET out of range index - linkedlist
[[0;32;49mok[0m]: LSET - ziplist
[[0;32;49mok[0m]: LSET out of range index - ziplist
[[0;32;49mok[0m]: LSET against non existing key
[[0;32;49mok[0m]: LSET against non list value
[[0;32;49mok[0m]: LREM remove all the occurrences - linkedlist
[[0;32;49mok[0m]: LREM remove the first occurrence - linkedlist
[[0;32;49mok[0m]: LREM remove non existing element - linkedlist
[[0;32;49mok[0m]: LREM starting from tail with negative count - linkedlist
[[0;32;49mok[0m]: LREM starting from tail with negative count (2) - linkedlist
[[0;32;49mok[0m]: LREM deleting objects that may be int encoded - linkedlist
[[0;32;49mok[0m]: LREM remove all the occurrences - ziplist
[[0;32;49mok[0m]: LREM remove the first occurrence - ziplist
[[0;32;49mok[0m]: LREM remove non existing element - ziplist
[[0;32;49mok[0m]: LREM starting from tail with negative count - ziplist
[[0;32;49mok[0m]: LREM starting from tail with negative count (2) - ziplist
[[0;32;49mok[0m]: LREM deleting objects that may be int encoded - ziplist
[[0;32;49mok[0m]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-value is exceeded
[19/50 [0;33;49mdone[0m]: integration/convert-zipmap-hash-on-load (1 seconds)
[1;37;49mTesting unit/pubsub[0m
[[0;32;49mok[0m]: Pub/Sub PING
[[0;32;49mok[0m]: PUBLISH/SUBSCRIBE basics
[[0;32;49mok[0m]: PUBLISH/SUBSCRIBE with two clients
[[0;32;49mok[0m]: PUBLISH/SUBSCRIBE after UNSUBSCRIBE without arguments
[[0;32;49mok[0m]: SUBSCRIBE to one channel more than once
[[0;32;49mok[0m]: UNSUBSCRIBE from non-subscribed channels
[[0;32;49mok[0m]: PUBLISH/PSUBSCRIBE basics
[[0;32;49mok[0m]: PUBLISH/PSUBSCRIBE with two clients
[[0;32;49mok[0m]: PUBLISH/PSUBSCRIBE after PUNSUBSCRIBE without arguments
[[0;32;49mok[0m]: PUNSUBSCRIBE from non-subscribed channels
[[0;32;49mok[0m]: NUMSUB returns numbers, not strings (#1561)
[[0;32;49mok[0m]: Mix SUBSCRIBE and PSUBSCRIBE
[[0;32;49mok[0m]: PUNSUBSCRIBE and UNSUBSCRIBE should always reply
[[0;32;49mok[0m]: Keyspace notifications: we receive keyspace notifications
[[0;32;49mok[0m]: Keyspace notifications: we receive keyevent notifications
[[0;32;49mok[0m]: Keyspace notifications: we can receive both kind of events
[[0;32;49mok[0m]: Keyspace notifications: we are able to mask events
[[0;32;49mok[0m]: Keyspace notifications: general events test
[[0;32;49mok[0m]: Keyspace notifications: list events test
[[0;32;49mok[0m]: Keyspace notifications: set events test
[[0;32;49mok[0m]: Keyspace notifications: zset events test
[[0;32;49mok[0m]: Keyspace notifications: hash events test
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 1 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #2 as master
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #2
[[0;32;49mok[0m]: PSYNC2: Set #0 to replicate from #1
[[0;32;49mok[0m]: PSYNC2: Set #4 to replicate from #2
[[0;32;49mok[0m]: PSYNC2: Set #3 to replicate from #1
[[0;32;49mok[0m]: No write if min-slaves-max-lag is > of the slave lag
[[0;32;49mok[0m]: min-slaves-to-write is ignored by slaves
[[0;32;49mok[0m]: Keyspace notifications: expired events (triggered expire)
[[0;32;49mok[0m]: Keyspace notifications: expired events (background expire)
[[0;32;49mok[0m]: Keyspace notifications: evicted events
[[0;32;49mok[0m]: Keyspace notifications: test CONFIG GET/SET of event flags
[20/50 [0;33;49mdone[0m]: unit/pubsub (1 seconds)
[1;37;49mTesting unit/slowlog[0m
[[0;32;49mok[0m]: SLOWLOG - check that it starts with an empty log
[[0;32;49mok[0m]: Regression for bug 593 - chaining BRPOPLPUSH with other blocking cmds
[21/50 [0;33;49mdone[0m]: unit/type/list (13 seconds)
[1;37;49mTesting unit/scripting[0m
[[0;32;49mok[0m]: SLOWLOG - only logs commands taking more time than specified
[[0;32;49mok[0m]: SLOWLOG - max entries is correctly handled
[[0;32;49mok[0m]: SLOWLOG - GET optional argument to limit output len works
[[0;32;49mok[0m]: SLOWLOG - RESET subcommand works
[[0;32;49mok[0m]: EVAL - Does Lua interpreter replies to our requests?
[[0;32;49mok[0m]: EVAL - Lua integer -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua string -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua true boolean -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua false boolean -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua status code reply -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua error reply -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua table -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Are the KEYS and ARGV arrays populated correctly?
[[0;32;49mok[0m]: EVAL - is Lua able to call Redis API?
[[0;32;49mok[0m]: EVALSHA - Can we call a SHA1 if already defined?
[[0;32;49mok[0m]: EVALSHA - Can we call a SHA1 in uppercase?
[[0;32;49mok[0m]: EVALSHA - Do we get an error on invalid SHA1?
[[0;32;49mok[0m]: EVALSHA - Do we get an error on non defined SHA1?
[[0;32;49mok[0m]: EVAL - Redis integer -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis bulk -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis multi bulk -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis status reply -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis error reply -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis nil bulk reply -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Is the Lua client using the currently selected DB?
[[0;32;49mok[0m]: EVAL - SELECT inside Lua should not affect the caller
[[0;32;49mok[0m]: EVAL - Scripts can't run certain commands
[[0;32;49mok[0m]: EVAL - Scripts can't run certain commands
[[0;32;49mok[0m]: EVAL - No arguments to redis.call/pcall is considered an error
[[0;32;49mok[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[[0;32;49mok[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[[0;32;49mok[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[[0;32;49mok[0m]: PSYNC2 #3899 regression: setup
[[0;32;49mok[0m]: EVAL - JSON numeric decoding
[[0;32;49mok[0m]: EVAL - JSON string decoding
[[0;32;49mok[0m]: EVAL - cmsgpack can pack double?
[[0;32;49mok[0m]: EVAL - cmsgpack can pack negative int64?
[[0;32;49mok[0m]: EVAL - cmsgpack can pack and unpack circular references?
[[0;32;49mok[0m]: EVAL - Numerical sanity check from bitop
[[0;32;49mok[0m]: EVAL - Verify minimal bitop functionality
[[0;32;49mok[0m]: EVAL - Able to parse trailing comments
[[0;32;49mok[0m]: SCRIPTING FLUSH - is able to clear the scripts cache?
[[0;32;49mok[0m]: SCRIPT EXISTS - can detect already defined scripts?
[[0;32;49mok[0m]: SCRIPT LOAD - is able to register scripts in the scripting cache
[[0;32;49mok[0m]: In the context of Lua the output of random commands gets ordered
[[0;32;49mok[0m]: SORT is normally not alpha re-ordered for the scripting engine
[[0;32;49mok[0m]: SORT BY <constant> output gets ordered for scripting
[[0;32;49mok[0m]: SORT BY <constant> with GET gets ordered for scripting
[[0;32;49mok[0m]: redis.sha1hex() implementation
[[0;32;49mok[0m]: Globals protection reading an undeclared global variable
[[0;32;49mok[0m]: Globals protection setting an undeclared global*
[[0;32;49mok[0m]: Test an example script DECR_IF_GT
[[0;32;49mok[0m]: Scripting engine resets PRNG at every script execution
[[0;32;49mok[0m]: Scripting engine PRNG can be seeded correctly
[[0;32;49mok[0m]: SLOWLOG - logged entry sanity check
[[0;32;49mok[0m]: SLOWLOG - commands with too many arguments are trimmed
[[0;32;49mok[0m]: SLOWLOG - too long arguments are trimmed
[[0;32;49mok[0m]: EVAL does not leak in the Lua stack
[[0;32;49mok[0m]: SLOWLOG - EXEC is not logged, just executed commands
[[0;32;49mok[0m]: EVAL processes writes from AOF in read-only slaves
[[0;32;49mok[0m]: We can call scripts rewriting client->argv from Lua
[[0;32;49mok[0m]: Call Redis command with many args from Lua (issue #1764)
[[0;32;49mok[0m]: Number conversion precision test (issue #1118)
[[0;32;49mok[0m]: String containing number precision test (regression of issue #1118)
[[0;32;49mok[0m]: Verify negative arg count is error instead of crash (issue #1842)
[[0;32;49mok[0m]: Correct handling of reused argv (issue #1939)
[[0;32;49mok[0m]: Functions in the Redis namespace are able to report errors
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: SLOWLOG - can clean older entires
[[0;32;49mok[0m]: SLOWLOG - can be disabled
[22/50 [0;33;49mdone[0m]: unit/slowlog (1 seconds)
[1;37;49mTesting unit/maxmemory[0m
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: Timedout read-only scripts can be killed by SCRIPT KILL
[[0;32;49mok[0m]: Timedout script link is still usable after Lua returns
[[0;32;49mok[0m]: Without maxmemory small integers are shared
[[0;32;49mok[0m]: With maxmemory and non-LRU policy integers are still shared
[[0;32;49mok[0m]: With maxmemory and LRU policy integers are not shared
[[0;32;49mok[0m]: Timedout scripts that modified data can't be killed by SCRIPT KILL
[[0;32;49mok[0m]: SHUTDOWN NOSAVE can kill a timedout script anyway
[[0;32;49mok[0m]: SET - use EX/PX option, TTL should not be reseted after loadaof
[23/50 [0;33;49mdone[0m]: unit/expire (14 seconds)
[1;37;49mTesting unit/introspection[0m
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy allkeys-random)
[[0;32;49mok[0m]: CLIENT LIST
[[0;32;49mok[0m]: MONITOR can log executed commands
[[0;32;49mok[0m]: MONITOR can log commands issued by the scripting engine
[[0;32;49mok[0m]: CLIENT GETNAME should return NIL if name is not assigned
[[0;32;49mok[0m]: CLIENT LIST shows empty fields for unassigned names
[[0;32;49mok[0m]: CLIENT SETNAME does not accept spaces
[[0;32;49mok[0m]: CLIENT SETNAME can assign a name to this connection
[[0;32;49mok[0m]: CLIENT SETNAME can change the name of an existing connection
[[0;32;49mok[0m]: After CLIENT SETNAME, connection can still be closed
[[0;32;49mok[0m]: Before the replica connects we issue two EVAL commands (scripts replication)
[[0;32;49mok[0m]: Slave is able to detect timeout during handshake
[24/50 [0;33;49mdone[0m]: unit/introspection (0 seconds)
[1;37;49mTesting unit/introspection-2[0m
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy allkeys-lru)
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: MIGRATE cached connections are released after some time
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: Test replication with parallel clients writing in differnet DBs
[[0;32;49mok[0m]: Stress tester for #3343-alike bugs
[[0;32;49mok[0m]: Connect a replica to the master instance (scripts replication)
[[0;32;49mok[0m]: Now use EVALSHA against the master, with both SHAs (scripts replication)
[[0;32;49mok[0m]: If EVALSHA was replicated as EVAL, 'x' should be '4' (scripts replication)
[[0;32;49mok[0m]: Replication of script multiple pushes to list with BLPOP (scripts replication)
[[0;32;49mok[0m]: EVALSHA replication when first call is readonly (scripts replication)
[[0;32;49mok[0m]: Lua scripts using SELECT are replicated correctly (scripts replication)
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy allkeys-lfu)
[[0;32;49mok[0m]: MIGRATE is able to migrate a key between two instances
[[0;32;49mok[0m]: LTRIM stress testing - ziplist
[25/50 [0;33;49mdone[0m]: unit/type/list-2 (16 seconds)
[1;37;49mTesting unit/limits[0m
[[0;32;49mok[0m]: MIGRATE is able to copy a key between two instances
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy volatile-lru)
[[0;32;49mok[0m]: Before the replica connects we issue two EVAL commands (commmands replication)
[[0;32;49mok[0m]: MIGRATE will not overwrite existing keys, unless REPLACE is used
[[0;32;49mok[0m]: Set instance A as slave of B
[[0;32;49mok[0m]: BRPOPLPUSH replication, when blocking against empty list
[[0;32;49mok[0m]: MASTER and SLAVE consistency with expire
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy volatile-lfu)
[[0;32;49mok[0m]: MIGRATE propagates TTL correctly
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: Check if maxclients works refusing connections
[[0;32;49mok[0m]: Connect a replica to the master instance (commmands replication)
[[0;32;49mok[0m]: Now use EVALSHA against the master, with both SHAs (commmands replication)
[[0;32;49mok[0m]: If EVALSHA was replicated as EVAL, 'x' should be '4' (commmands replication)
[[0;32;49mok[0m]: Replication of script multiple pushes to list with BLPOP (commmands replication)
[[0;32;49mok[0m]: EVALSHA replication when first call is readonly (commmands replication)
[[0;32;49mok[0m]: Lua scripts using SELECT are replicated correctly (commmands replication)
[26/50 [0;33;49mdone[0m]: unit/limits (2 seconds)
[1;37;49mTesting unit/obuf-limits[0m
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: With min-slaves-to-write (1,3): master should be writable
[[0;32;49mok[0m]: With min-slaves-to-write (2,3): master should not be writable
[[0;32;49mok[0m]: BRPOPLPUSH replication, list exists
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy volatile-random)
[[0;32;49mok[0m]: Test replication partial resync: ok psync (diskless: no, reconnect: 1)
[[0;32;49mok[0m]: BLPOP followed by role change, issue #2473
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy volatile-ttl)
[[0;32;49mok[0m]: TTL and TYPYE do not alter the last access time of a key
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: Second server should have role master at first
[[0;32;49mok[0m]: SLAVEOF should start with link status "down"
[[0;32;49mok[0m]: The role should immediately be changed to "replica"
[[0;32;49mok[0m]: Connect a replica to the master instance
[[0;32;49mok[0m]: Redis.replicate_commands() must be issued before any write
[[0;32;49mok[0m]: Redis.replicate_commands() must be issued before any write (2)
[[0;32;49mok[0m]: Redis.set_repl() must be issued after replicate_commands()
[[0;32;49mok[0m]: Redis.set_repl() don't accept invalid values
[[0;32;49mok[0m]: Test selective replication of certain Redis commands from Lua
[[0;32;49mok[0m]: PRNG is seeded randomly for command replication
[[0;32;49mok[0m]: Using side effects is not a problem with command replication
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 22207)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 2 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #3 as master
[[0;32;49mok[0m]: PSYNC2: Set #0 to replicate from #3
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #2 to replicate from #1
[[0;32;49mok[0m]: PSYNC2: Set #4 to replicate from #1
[27/50 [0;33;49mdone[0m]: unit/scripting (6 seconds)
[1;37;49mTesting unit/bitops[0m
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (allkeys-random)
[[0;32;49mok[0m]: BITCOUNT returns 0 against non existing key
[[0;32;49mok[0m]: BITCOUNT returns 0 with out of range indexes
[[0;32;49mok[0m]: BITCOUNT returns 0 with negative indexes where start > end
[[0;32;49mok[0m]: BITCOUNT against test vector #1
[[0;32;49mok[0m]: BITCOUNT against test vector #2
[[0;32;49mok[0m]: BITCOUNT against test vector #3
[[0;32;49mok[0m]: BITCOUNT against test vector #4
[[0;32;49mok[0m]: BITCOUNT against test vector #5
[[0;32;49mok[0m]: Sync should have transferred keys from master
[[0;32;49mok[0m]: The link status should be up
[[0;32;49mok[0m]: SET on the master should immediately propagate
[[0;32;49mok[0m]: FLUSHALL should replicate
[[0;32;49mok[0m]: ROLE in master reports master with a slave
[[0;32;49mok[0m]: ROLE in slave reports slave in connected state
[[0;32;49mok[0m]: XRANGE fuzzing
[[0;32;49mok[0m]: XREVRANGE regression test for issue #5006
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: BITCOUNT fuzzing without start/end
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (allkeys-lru)
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: XADD with MAXLEN > xlen can propagate correctly
[[0;32;49mok[0m]: ziplist implementation: value encoding and backlink
[[0;32;49mok[0m]: BITCOUNT fuzzing with start/end
[[0;32;49mok[0m]: BITCOUNT with start, end
[[0;32;49mok[0m]: BITCOUNT syntax error #1
[[0;32;49mok[0m]: BITCOUNT regression test for github issue #582
[[0;32;49mok[0m]: BITCOUNT misaligned prefix
[[0;32;49mok[0m]: BITCOUNT misaligned prefix + full words + remainder
[[0;32;49mok[0m]: BITOP NOT (empty string)
[[0;32;49mok[0m]: BITOP NOT (known string)
[[0;32;49mok[0m]: BITOP where dest and target are the same key
[[0;32;49mok[0m]: BITOP AND|OR|XOR don't change the string with single input key
[[0;32;49mok[0m]: BITOP missing key is considered a stream of zero
[[0;32;49mok[0m]: BITOP shorter keys are zero-padded to the key with max length
[[0;32;49mok[0m]: XADD with ~ MAXLEN can propagate correctly
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-lru)
[[0;32;49mok[0m]: XTRIM with ~ MAXLEN can propagate correctly
[[0;32;49mok[0m]: BITOP and fuzzing
[[0;32;49mok[0m]: TOUCH alters the last access time of a key
[[0;32;49mok[0m]: TOUCH returns the number of existing keys specified
[[0;32;49mok[0m]: command stats for GEOADD
[[0;32;49mok[0m]: command stats for EXPIRE
[[0;32;49mok[0m]: command stats for BRPOP
[[0;32;49mok[0m]: command stats for MULTI
[[0;32;49mok[0m]: command stats for scripts
[[0;32;49mok[0m]: With min-slaves-to-write: master not writable with lagged slave
[28/50 [0;33;49mdone[0m]: unit/introspection-2 (7 seconds)
[1;37;49mTesting unit/bitfield[0m
[[0;32;49mok[0m]: XADD can CREATE an empty stream
[[0;32;49mok[0m]: XSETID can set a specific ID
[[0;32;49mok[0m]: XSETID cannot SETID with smaller ID
[[0;32;49mok[0m]: XSETID cannot SETID on non-existent key
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-random)
[[0;32;49mok[0m]: BITFIELD signed SET and GET basics
[[0;32;49mok[0m]: BITFIELD unsigned SET and GET basics
[[0;32;49mok[0m]: BITFIELD #<idx> form
[[0;32;49mok[0m]: BITFIELD basic INCRBY form
[[0;32;49mok[0m]: BITFIELD chaining of multiple commands
[[0;32;49mok[0m]: BITFIELD unsigned overflow wrap
[[0;32;49mok[0m]: BITFIELD unsigned overflow sat
[[0;32;49mok[0m]: BITFIELD signed overflow wrap
[[0;32;49mok[0m]: BITFIELD signed overflow sat
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: BITOP or fuzzing
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: Slave is able to evict keys created in writable slaves
[[0;32;49mok[0m]: BITFIELD overflow detection fuzzing
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: BITOP xor fuzzing
[[0;32;49mok[0m]: BITOP NOT fuzzing
[[0;32;49mok[0m]: BITOP with integer encoded source objects
[[0;32;49mok[0m]: BITOP with non string source key
[[0;32;49mok[0m]: BITOP with empty string after non empty string (issue #529)
[[0;32;49mok[0m]: BITPOS bit=0 with empty key returns 0
[[0;32;49mok[0m]: BITPOS bit=1 with empty key returns -1
[[0;32;49mok[0m]: BITPOS bit=0 with string less than 1 word works
[[0;32;49mok[0m]: Empty stream can be rewrite into AOF correctly
[[0;32;49mok[0m]: BITPOS bit=1 with string less than 1 word works
[[0;32;49mok[0m]: BITPOS bit=0 starting at unaligned address
[[0;32;49mok[0m]: BITPOS bit=1 starting at unaligned address
[[0;32;49mok[0m]: BITPOS bit=0 unaligned+full word+reminder
[[0;32;49mok[0m]: BITPOS bit=1 unaligned+full word+reminder
[[0;32;49mok[0m]: BITPOS bit=1 returns -1 if string is all 0 bits
[[0;32;49mok[0m]: BITPOS bit=0 works with intervals
[[0;32;49mok[0m]: BITPOS bit=1 works with intervals
[[0;32;49mok[0m]: BITPOS bit=0 changes behavior if end is given
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-ttl)
[[0;32;49mok[0m]: BITFIELD overflow wrap fuzzing
[[0;32;49mok[0m]: BITFIELD regression for #3221
[[0;32;49mok[0m]: BITFIELD regression for #3564
[[0;32;49mok[0m]: BITPOS bit=1 fuzzy testing using SETBIT
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[29/50 [0;33;49mdone[0m]: unit/bitfield (3 seconds)
[1;37;49mTesting unit/geo[0m
[[0;32;49mok[0m]: Stream can be rewrite into AOF correctly after XDEL lastid
[[0;32;49mok[0m]: BITPOS bit=0 fuzzy testing using SETBIT
[[0;32;49mok[0m]: GEOADD create
[[0;32;49mok[0m]: GEOADD update
[[0;32;49mok[0m]: GEOADD invalid coordinates
[[0;32;49mok[0m]: GEOADD multi add
[[0;32;49mok[0m]: Check geoset values
[[0;32;49mok[0m]: GEORADIUS simple (sorted)
[[0;32;49mok[0m]: GEORADIUS withdist (sorted)
[[0;32;49mok[0m]: GEORADIUS with COUNT
[[0;32;49mok[0m]: GEORADIUS with COUNT but missing integer argument
[[0;32;49mok[0m]: GEORADIUS with COUNT DESC
[[0;32;49mok[0m]: GEORADIUS HUGE, issue #2767
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: GEORADIUSBYMEMBER simple (sorted)
[[0;32;49mok[0m]: GEORADIUSBYMEMBER withdist (sorted)
[[0;32;49mok[0m]: GEOHASH is able to return geohash strings
[[0;32;49mok[0m]: GEOPOS simple
[[0;32;49mok[0m]: GEOPOS missing element
[[0;32;49mok[0m]: GEODIST simple & unit
[[0;32;49mok[0m]: GEODIST missing elements
[[0;32;49mok[0m]: GEORADIUS STORE option: syntax error
[[0;32;49mok[0m]: GEORANGE STORE option: incompatible options
[[0;32;49mok[0m]: GEORANGE STORE option: plain usage
[[0;32;49mok[0m]: GEORANGE STOREDIST option: plain usage
[[0;32;49mok[0m]: GEORANGE STOREDIST option: COUNT ASC and DESC
[30/50 [0;33;49mdone[0m]: unit/type/stream (25 seconds)
[1;37;49mTesting unit/memefficiency[0m
[31/50 [0;33;49mdone[0m]: unit/bitops (6 seconds)
[1;37;49mTesting unit/hyperloglog[0m
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: maxmemory - policy volatile-lru should only remove volatile keys.
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: maxmemory - policy volatile-lfu should only remove volatile keys.
[[0;32;49mok[0m]: Memory efficiency with values in range 32
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 39220)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 3 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #4 as master
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #4
[[0;32;49mok[0m]: PSYNC2: Set #0 to replicate from #1
[[0;32;49mok[0m]: PSYNC2: Set #2 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #3 to replicate from #2
[[0;32;49mok[0m]: maxmemory - policy volatile-random should only remove volatile keys.
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: Test replication partial resync: no backlog (diskless: no, reconnect: 1)
[[0;32;49mok[0m]: Memory efficiency with values in range 64
[[0;32;49mok[0m]: maxmemory - policy volatile-ttl should only remove volatile keys.
[[0;32;49mok[0m]: Test replication with blocking lists and sorted sets operations
[[0;32;49mok[0m]: HyperLogLog self test passes
[[0;32;49mok[0m]: PFADD without arguments creates an HLL value
[[0;32;49mok[0m]: Approximated cardinality after creation is zero
[[0;32;49mok[0m]: PFADD returns 1 when at least 1 reg was modified
[[0;32;49mok[0m]: PFADD returns 0 when no reg was modified
[[0;32;49mok[0m]: PFADD works with empty string (regression)
[[0;32;49mok[0m]: PFCOUNT returns approximated cardinality of set
[32/50 [0;33;49mdone[0m]: integration/block-repl (27 seconds)
[1;37;49mTesting unit/lazyfree[0m
[[0;32;49mok[0m]: Memory efficiency with values in range 128
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: HyperLogLogs are promote from sparse to dense
[[0;32;49mok[0m]: UNLINK can reclaim memory in background
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: MASTER and SLAVE dataset should be identical after complex ops
[[0;32;49mok[0m]: Memory efficiency with values in range 1024
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: FLUSHDB ASYNC can reclaim memory in background
[[0;32;49mok[0m]: Client output buffer hard limit is enforced
[33/50 [0;33;49mdone[0m]: unit/lazyfree (2 seconds)
[1;37;49mTesting unit/wait[0m
[34/50 [0;33;49mdone[0m]: integration/replication-2 (27 seconds)
[1;37;49mTesting unit/pendingquerybuf[0m
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: Setup slave
[[0;32;49mok[0m]: WAIT should acknowledge 1 additional copy of the data
[[0;32;49mok[0m]: HyperLogLog sparse encoding stress test
[[0;32;49mok[0m]: Corrupted sparse HyperLogLogs are detected: Additionl at tail
[[0;32;49mok[0m]: Corrupted sparse HyperLogLogs are detected: Broken magic
[[0;32;49mok[0m]: Corrupted sparse HyperLogLogs are detected: Invalid encoding
[[0;32;49mok[0m]: Corrupted dense HyperLogLogs are detected: Wrong length
[[0;32;49mok[0m]: PSYNC2 #3899 regression: verify consistency
[[0;32;49mok[0m]: MIGRATE can correctly transfer large values
[[0;32;49mok[0m]: WAIT should not acknowledge 2 additional copies of the data
[[0;32;49mok[0m]: MIGRATE can correctly transfer hashes
[[0;32;49mok[0m]: Memory efficiency with values in range 16384
[35/50 [0;33;49mdone[0m]: integration/psync2-reg (23 seconds)
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 59866)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: MIGRATE timeout actually works
[[0;32;49mok[0m]: PSYNC2: Bring the master back again for next test
[[0;32;49mok[0m]: MIGRATE can migrate multiple keys at once
[[0;32;49mok[0m]: MIGRATE with multiple keys must have empty key arg
[[0;32;49mok[0m]: MIGRATE with multiple keys migrate just existing ones
[[0;32;49mok[0m]: PSYNC2: Partial resync after restart using RDB aux fields
[[0;32;49mok[0m]: MIGRATE with multiple keys: stress command rewriting
[[0;32;49mok[0m]: MIGRATE with multiple keys: delete just ack keys
[[0;32;49mok[0m]: MIGRATE AUTH: correct and wrong password cases
[36/50 [0;33;49mdone[0m]: unit/dump (39 seconds)
[[0;32;49mok[0m]: WAIT should not acknowledge 1 additional copy if slave is blocked
[37/50 [0;33;49mdone[0m]: unit/wait (7 seconds)
[[0;32;49mok[0m]: PSYNC2: Replica RDB restart with EVALSHA in backlog issue #4483
[[0;32;49mok[0m]: AOF rewrite during write load: RDB preamble=yes
[38/50 [0;33;49mdone[0m]: integration/psync2 (29 seconds)
[[0;32;49mok[0m]: Test replication partial resync: ok after delay (diskless: no, reconnect: 1)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: ziplist implementation: encoding stress testing
[[0;32;49mok[0m]: pending querybuf: check size of pending_querybuf after set a big value
[39/50 [0;33;49mdone[0m]: unit/type/list-3 (44 seconds)
[40/50 [0;33;49mdone[0m]: unit/pendingquerybuf (13 seconds)
[[0;32;49mok[0m]: Active defrag
[[0;32;49mok[0m]: Client output buffer soft limit is not enforced if time is not overreached
[[0;32;49mok[0m]: Connect multiple replicas at the same time (issue #141), diskless=no
[[0;32;49mok[0m]: Test replication partial resync: backlog expired (diskless: no, reconnect: 1)
[[0;32;49mok[0m]: MASTER and SLAVE consistency with EVALSHA replication
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: no reconnection, just sync (diskless: yes, reconnect: 0)
[[0;32;49mok[0m]: SLAVE can reload "lua" AUX RDB fields of duplicated scripts
[[0;32;49mok[0m]: GEOADD + GEORANGE randomized test
[41/50 [0;33;49mdone[0m]: unit/geo (35 seconds)
[42/50 [0;33;49mdone[0m]: integration/replication-3 (53 seconds)
[[0;32;49mok[0m]: Replication: commands with many arguments (issue #1221)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Client output buffer soft limit is enforced if time is overreached
[43/50 [0;33;49mdone[0m]: unit/obuf-limits (45 seconds)
[[0;32;49mok[0m]: Replication of SPOP command -- alsoPropagate() API
[44/50 [0;33;49mdone[0m]: integration/replication-4 (57 seconds)
[[0;32;49mok[0m]: Fuzzing dense/sparse encoding: Redis should always detect errors
[[0;32;49mok[0m]: PFADD, PFCOUNT, PFMERGE type checking works
[[0;32;49mok[0m]: PFMERGE results on the cardinality of union of sets
[[0;32;49mok[0m]: Test replication partial resync: ok psync (diskless: yes, reconnect: 1)
[[0;32;49mok[0m]: slave buffer are counted correctly
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: PFCOUNT multiple-keys merge returns cardinality of union #1
[[0;32;49mok[0m]: PFCOUNT multiple-keys merge returns cardinality of union #2
[[0;32;49mok[0m]: PFDEBUG GETREG returns the HyperLogLog raw registers
[[0;32;49mok[0m]: PFADD / PFCOUNT cache invalidation works
[45/50 [0;33;49mdone[0m]: unit/hyperloglog (54 seconds)
[[0;32;49mok[0m]: replica buffer don't induce eviction
[[0;32;49mok[0m]: Test replication partial resync: no backlog (diskless: yes, reconnect: 1)
[46/50 [0;33;49mdone[0m]: unit/maxmemory (67 seconds)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: AOF rewrite during write load: RDB preamble=no
[[0;32;49mok[0m]: Turning off AOF kills the background writing child if any
[[0;32;49mok[0m]: Active defrag big keys
[47/50 [0;33;49mdone[0m]: unit/memefficiency (67 seconds)
[[0;32;49mok[0m]: AOF rewrite of list with quicklist encoding, string data
[[0;32;49mok[0m]: Connect multiple replicas at the same time (issue #141), diskless=yes
[[0;32;49mok[0m]: AOF rewrite of list with quicklist encoding, int data
[[0;32;49mok[0m]: AOF rewrite of set with intset encoding, string data
[[0;32;49mok[0m]: Test replication partial resync: ok after delay (diskless: yes, reconnect: 1)
[[0;32;49mok[0m]: AOF rewrite of set with hashtable encoding, string data
[[0;32;49mok[0m]: AOF rewrite of set with intset encoding, int data
[[0;32;49mok[0m]: AOF rewrite of set with hashtable encoding, int data
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: AOF rewrite of hash with ziplist encoding, string data
[[0;32;49mok[0m]: AOF rewrite of hash with hashtable encoding, string data
[[0;32;49mok[0m]: AOF rewrite of hash with ziplist encoding, int data
[[0;32;49mok[0m]: AOF rewrite of hash with hashtable encoding, int data
[[0;32;49mok[0m]: AOF rewrite of zset with ziplist encoding, string data
[[0;32;49mok[0m]: AOF rewrite of zset with skiplist encoding, string data
[[0;32;49mok[0m]: AOF rewrite of zset with ziplist encoding, int data
[[0;32;49mok[0m]: AOF rewrite of zset with skiplist encoding, int data
[[0;32;49mok[0m]: BGREWRITEAOF is delayed if BGSAVE is in progress
[[0;32;49mok[0m]: BGREWRITEAOF is refused if already in progress
[48/50 [0;33;49mdone[0m]: unit/aofrw (104 seconds)
[[0;32;49mok[0m]: Test replication partial resync: backlog expired (diskless: yes, reconnect: 1)
[49/50 [0;33;49mdone[0m]: integration/replication-psync (100 seconds)
[[0;32;49mok[0m]: Master stream is correctly processed while the replica has a script in -BUSY state
[50/50 [0;33;49mdone[0m]: integration/replication (115 seconds)

                   The End

Execution time of different units:
  0 seconds - unit/printver
  1 seconds - unit/type/incr
  1 seconds - unit/auth
  1 seconds - unit/protocol
  2 seconds - unit/keyspace
  0 seconds - unit/quit
  2 seconds - unit/multi
  4 seconds - unit/type/stream-cgroups
  5 seconds - unit/type/hash
  7 seconds - unit/type/set
  8 seconds - unit/sort
  8 seconds - unit/scan
  9 seconds - unit/type/string
  9 seconds - unit/other
  11 seconds - unit/type/zset
  1 seconds - integration/rdb
  3 seconds - integration/aof
  1 seconds - integration/logging
  1 seconds - integration/convert-zipmap-hash-on-load
  1 seconds - unit/pubsub
  13 seconds - unit/type/list
  1 seconds - unit/slowlog
  14 seconds - unit/expire
  0 seconds - unit/introspection
  16 seconds - unit/type/list-2
  2 seconds - unit/limits
  6 seconds - unit/scripting
  7 seconds - unit/introspection-2
  3 seconds - unit/bitfield
  25 seconds - unit/type/stream
  6 seconds - unit/bitops
  27 seconds - integration/block-repl
  2 seconds - unit/lazyfree
  27 seconds - integration/replication-2
  23 seconds - integration/psync2-reg
  39 seconds - unit/dump
  7 seconds - unit/wait
  29 seconds - integration/psync2
  44 seconds - unit/type/list-3
  13 seconds - unit/pendingquerybuf
  35 seconds - unit/geo
  53 seconds - integration/replication-3
  45 seconds - unit/obuf-limits
  57 seconds - integration/replication-4
  54 seconds - unit/hyperloglog
  67 seconds - unit/maxmemory
  67 seconds - unit/memefficiency
  104 seconds - unit/aofrw
  100 seconds - integration/replication-psync
  115 seconds - integration/replication

[1;37;49m\o/[0m [1;32;49mAll tests passed without errors![0m

Cleanup: may take some time... OK
make[1]: Leaving directory '/home/lasse/Documents/C-programs/C/redis-5.0.7/src'
